name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: null

jobs:
  build-and-test-none:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4.1.6

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            autoconf autopoint automake libtool build-essential pkg-config \
            clang valgrind gettext docbook-to-man xorg xauth \
            libx11-dev libpango1.0-dev libglib2.0-dev \
            libstartup-notification0-dev libxrandr-dev libxinerama-dev \
            libxcursor-dev libimlib2-dev librsvg2-dev \
            xvfb dbus-x11 xinit

      - name: Configure and build
        shell: bash
        run: |
          autoreconf -vif
          export CC=clang
          export SANITIZER_FLAGS=""

          export CFLAGS="-g $SANITIZER_FLAGS"
          export LDFLAGS="$SANITIZER_FLAGS"

          INSTALL_DIR="/home/runner/install"
          mkdir -p $INSTALL_DIR
          ./configure --prefix=$INSTALL_DIR --disable-nls --enable-imlib2 --enable-librsvg --with-x --enable-debug --enable-session-management
          make -j"$(nproc)"
          make install

      - name: Start Xvfb and run Openbox
        shell: bash
        run: |
          export DISPLAY=:99
          sudo Xvfb -ac :99 -screen 0 1280x1024x24 > /dev/null 2>&1 &
          sleep 3  # Give Xvfb a moment to start
          echo "Xvfb started with DISPLAY=$DISPLAY"

          dbus-launch /home/runner/install/bin/openbox-session &

          sleep 5
          echo "Openbox should be running now."
          ps aux | grep X
          echo "DISPLAY=$DISPLAY"

          run_with_timeout() {
            local timeout_duration=$1
            shift  # Remove the first argument (timeout duration) from $@

            timeout --preserve-status $timeout_duration "$@" &
            local pid=$!

            # Wait for the process to finish
            wait $pid
            local status=$?

            # Check if the command was killed due to timeout (status 124 indicates timeout)
            if [ $status -eq 124 ]; then
              echo "[Timeout] Command '$*' was killed after $timeout_duration."
            elif [ $status -ne 0 ]; then
              echo "[Error] Command '$*' failed with status $status."
            fi

            echo "[Success] Command '$*' completed within the timeout."
            return 0
          }

          cd tests
          make -j16

          # Running tests with appropriate sanitizer options
          if [[ "${{ matrix.sanitizer }}" != "none" ]]; then
            export ASAN_OPTIONS=detect_leaks=1:halt_on_error=1:detect_odr_violation=1
            export UBSAN_OPTIONS=print_stacktrace=1:halt_on_error=1
          fi

          # Manually loop through and run each test executable
          for test in *; do
            if [[ -x "$test" && ! "$test" =~ \.c$ && ! "$test" =~ Makefile && ! "$test" =~ \.py && ! "$test" =~ \.sh ]]; then
              echo "[Running] $test"
              run_with_timeout 10s "./$test"
            fi
          done
